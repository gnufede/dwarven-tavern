// Generated by CoffeeScript 1.6.3
(function() {
  var createActionMoveTo, deffendingY, disconnected, getWantedBarrelPos, isEqualPos, joinSimulation, manhattanDistanceOne, myTeam, net, opponentTeam, runTurn, server, simulationId, targetY;

  net = require("net");

  simulationId = process.argv[2] != null ? process.argv[2] : null;

  server = null;

  disconnected = false;

  targetY = 0;

  deffendingY = 0;

  myTeam = "";

  opponentTeam = "";

  getWantedBarrelPos = function(barrelPos, wantedY) {
    return {
      x: barrelPos.x,
      y: barrelPos.y > wantedY ? barrelPos.y + 1 : barrelPos.y - 1
    };
  };

  manhattanDistanceOne = function(pos1, pos2) {
    var distanceX, distanceY;
    distanceX = Math.abs(pos1.x - pos2.x);
    distanceY = Math.abs(pos1.y - pos2.y);
    return distanceX + distanceY === 1;
  };

  isEqualPos = function(pos1, pos2) {
    if (pos1 && pos2) {
      return pos1.x === pos2.x && pos1.y === pos2.y;
    }
    return false;
  };

  createActionMoveTo = function(bot, toPosition, toEvit) {
    var direction;
    if (bot.coords.x < toPosition.x && !isEqualPos(toEvit, {
      x: bot.coords.x + 1,
      y: bot.coords.y
    })) {
      direction = "EAST";
    }
    if (bot.coords.x > toPosition.x && !isEqualPos(toEvit, {
      x: bot.coords.x - 1,
      y: bot.coords.y
    })) {
      direction = "WEST";
    }
    if (bot.coords.y < toPosition.y && !isEqualPos(toEvit, {
      x: bot.coords.x,
      y: bot.coords.y + 1
    })) {
      direction = "SOUTH";
    }
    if (bot.coords.y > toPosition.y && !isEqualPos(toEvit, {
      x: bot.coords.x,
      y: bot.coords.y - 1
    })) {
      direction = "NORTH";
    }
    if (direction != null) {
      return {
        botId: bot.id,
        type: "MOVE",
        direction: direction
      };
    } else {
      return {
        botId: bot.id,
        type: "PASS"
      };
    }
  };

  runTurn = function(state) {
    var actions, attackerBotLogic, attackers, bot, canProtectBarrelLogic, defenderBotLogic, defenders, myTeamBarrel, opponentBarrel, opponents, protectBarrelLogic, pushOpponentsLogic, turnMessage, _i, _j, _len, _len1;
    myTeamBarrel = state["barrels"][myTeam]["coords"];
    opponentBarrel = state["barrels"][opponentTeam]["coords"];
    opponents = state[opponentTeam];
    attackers = [];
    defenders = [];
    actions = [];
    pushOpponentsLogic = function(bot, opponents) {
      var opponent, push, _i, _len;
      push = false;
      if (opponents) {
        for (_i = 0, _len = opponents.length; _i < _len; _i++) {
          opponent = opponents[_i];
          if (!push) {
            push = push || manhattanDistanceOne(bot.coords, opponent.coords);
            if (push) {
              actions.push(createActionMoveTo(bot, opponent.coords));
            }
          }
        }
      }
      return push;
    };
    canProtectBarrelLogic = function(bot, barrel, opponents) {
      var opponent, push, _i, _len;
      push = false;
      if ((manhattanDistanceOne(bot.coords, barrel)) && opponents) {
        for (_i = 0, _len = opponents.length; _i < _len; _i++) {
          opponent = opponents[_i];
          push = push || (manhattanDistanceOne(opponent.coords, barrel));
        }
      }
      return push;
    };
    protectBarrelLogic = function(bot, opponents) {
      if (canProtectBarrelLogic(bot, myTeamBarrel, opponents)) {
        actions.push(createActionMoveTo(bot, myTeamBarrel));
        return true;
      } else if (canProtectBarrelLogic(bot, opponentBarrel, opponents)) {
        actions.push(createActionMoveTo(bot, opponentBarrel));
        return true;
      }
      return false;
    };
    attackerBotLogic = function(bot) {
      var wantedPos;
      wantedPos = getWantedBarrelPos(opponentBarrel, targetY);
      if (!protectBarrelLogic(bot, opponents)) {
        if (!pushOpponentsLogic(bot, opponents)) {
          if (isEqualPos(bot.coords, wantedPos)) {
            return actions.push(createActionMoveTo(bot, {
              x: bot.coords.x,
              y: targetY
            }, {
              x: -1,
              y: -1
            }));
          } else {
            return actions.push(createActionMoveTo(bot, wantedPos, opponentBarrel));
          }
        }
      }
    };
    defenderBotLogic = function(bot) {
      var wantedPos;
      wantedPos = getWantedBarrelPos(myTeamBarrel, deffendingY);
      if (!protectBarrelLogic(bot, opponents)) {
        if (!pushOpponentsLogic(bot, opponents)) {
          if (isEqualPos(bot.coords, wantedPos)) {
            return actions.push(createActionMoveTo(bot, {
              x: bot.coords.x,
              y: deffendingY
            }, {
              x: -1,
              y: -1
            }));
          } else {
            return actions.push(createActionMoveTo(bot, wantedPos, myTeamBarrel));
          }
        }
      }
    };
    attackers = [state[myTeam][0], state[myTeam][2], state[myTeam][4]];
    defenders = [state[myTeam][1], state[myTeam][3]];
    for (_i = 0, _len = attackers.length; _i < _len; _i++) {
      bot = attackers[_i];
      attackerBotLogic(bot);
    }
    for (_j = 0, _len1 = defenders.length; _j < _len1; _j++) {
      bot = defenders[_j];
      defenderBotLogic(bot);
    }
    turnMessage = {
      type: "player-turn",
      actions: actions
    };
    if (!disconnected) {
      return server.write(JSON.stringify(turnMessage));
    }
  };

  joinSimulation = function() {
    return server.write(JSON.stringify({
      simulationId: simulationId,
      type: "join-simulation",
      nick: "Drunk",
      names: ["Johnny Walker", "Toalabarra", "JägerMëister", "Delirium Tremens", "Pawël Kwak"]
    }));
  };

  server = net.connect({
    port: 9000
  }, joinSimulation);

  server.on("data", function(data) {
    var message;
    message = JSON.parse(data);
    switch (message["type"]) {
      case "game-info":
        myTeam = message["team"];
        if (myTeam === "team1") {
          targetY = message["height"];
          deffendingY = message["height"];
          return opponentTeam = "team2";
        } else {
          targetY = 0;
          deffendingY = 0;
          return opponentTeam = "team1";
        }
        break;
      case "ready":
        simulationId = message["simulationId"];
        return joinSimulation();
      case "turn":
        return runTurn(message["state"]);
      case "score":
        return console.log("SCORE");
      case "error":
        if (message["message"] === "Player disconnected") {
          console.log;
        }
        if (message["message"] === "Wrong simulation ID") {
          return server.write(JSON.stringify({
            type: "create-simulation"
          }));
        }
        break;
      default:
        return server.end();
    }
  });

  server.on("end", function() {
    disconnected = true;
    return console.log("END");
  });

}).call(this);
